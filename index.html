<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>é“¾æ¥æ”¶è—å¤¹</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script>
    // é…ç½®Tailwind CSS
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            'dark-bg': '#121212',
            'dark-card': '#1e1e12',
            'dark-border': '#2d2d2d',
            'dark-text': '#e0e0e0',
            'dark-secondary': '#a0a0a0'
          }
        }
      }
    }
  </script>
  <style>
    :root {
      --sidebar-width: 16rem;
    }
    
    .tag-pill {
      transition: all 0.2s ease;
    }
    .tag-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .link-card {
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    .link-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.1);
    }
    .link-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(to bottom, #3b82f6, #8b5cf6);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .link-card:hover::before {
      opacity: 1;
    }
    .sidebar {
      transition: transform 0.3s ease;
      width: var(--sidebar-width);
    }
    @media (max-width: 768px) {
      .sidebar.hidden-mobile {
        transform: translateX(-100%);
      }
    }
    .theme-toggle {
      transition: transform 0.3s ease;
    }
    .theme-toggle.dark {
      transform: rotate(180deg);
    }
    .dark .link-card:hover {
      box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }
    
    /* Favicon loader animation */
    @keyframes pulse {
      0% { opacity: 0.4; }
      50% { opacity: 1; }
      100% { opacity: 0.4; }
    }
    .favicon-loader {
      animation: pulse 1.5s infinite;
    }
    
    .loader {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top-color: #3b82f6;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* ç¼–è¾‘æ¨¡å¼æ ·å¼ */
    .edit-mode .link-card {
      cursor: move;
    }
    .edit-btn {
      transition: all 0.2s ease;
    }
    .edit-btn:hover {
      transform: scale(1.1);
    }
    .editor-panel {
      transition: all 0.3s ease;
    }
  </style>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-dark-bg dark:text-dark-text min-h-screen transition-colors duration-300">
  <div id="app" class="flex flex-col h-screen">
    <!-- åŠ è½½æŒ‡ç¤ºå™¨ -->
    <div id="loadingOverlay" class="fixed inset-0 bg-white dark:bg-dark-bg z-50 flex flex-col items-center justify-center transition-opacity duration-300">
      <div class="loader mb-4"></div>
      <p class="text-gray-600 dark:text-gray-400">åŠ è½½ä¸­...</p>
    </div>
    
    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <header class="bg-white shadow-sm border-b border-gray-200 dark:bg-dark-card dark:border-dark-border sticky top-0 z-20">
      <div class="px-4 py-3">
        <!-- æœç´¢æ  + ä¸»é¢˜åˆ‡æ¢ -->
        <div class="flex items-center gap-3 mb-3">
          <button id="menuToggle" class="md:hidden p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-dark-border">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
          </button>
          <div class="flex-1 relative">
            <input 
              type="text" 
              id="searchInput" 
              placeholder="æœç´¢... æ”¯æŒ tag:ä¸­æ–‡ -tag:ä»˜è´¹å¢™ è¯­æ³•"
              class="w-full px-4 py-2.5 pl-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none dark:bg-dark-card dark:border-dark-border dark:text-dark-text"
            >
            <svg class="w-5 h-5 text-gray-400 absolute left-3 top-1/2 -translate-y-1/2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
            </svg>
          </div>
          <div class="flex items-center gap-2">
            <button id="editModeToggle" class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-dark-border">
              <svg class="w-6 h-6 text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
              </svg>
            </button>
            <button id="themeToggle" class="theme-toggle p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-dark-border">
              <svg class="w-6 h-6 text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>
              </svg>
            </button>
          </div>
        </div>
        
        <!-- TagGroup é€‰æ‹©å™¨ -->
        <div class="flex items-center gap-2 overflow-x-auto pt-2 pb-1">
          <span class="text-sm text-gray-500 dark:text-gray-400 whitespace-nowrap">åˆ†ç»„:</span>
          <div id="tagGroupSelector" class="flex gap-2">
            <!-- åŠ¨æ€ç”Ÿæˆ -->
          </div>
        </div>
      </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
      <!-- å·¦ä¾§æ ‡ç­¾æ  -->
      <aside id="sidebar" class="sidebar bg-white border-r border-gray-200 dark:bg-dark-card dark:border-dark-border overflow-y-auto fixed md:relative h-full z-10 hidden-mobile md:block">
        <div class="p-4">
          <h3 id="sidebarTitle" class="text-sm font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-3">æ ‡ç­¾</h3>
          <div id="tagList" class="space-y-2">
            <!-- åŠ¨æ€ç”Ÿæˆ -->
          </div>
        </div>
      </aside>

      <!-- é®ç½©å±‚ -->
      <div id="overlay" class="fixed inset-0 bg-black/50 z-5 hidden md:hidden" onclick="toggleSidebar()"></div>

      <!-- å³ä¾§å†…å®¹åŒº -->
      <main class="flex-1 overflow-y-auto p-4 md:p-6">
        <div class="mb-6 flex items-center justify-between">
          <h1 class="text-2xl font-bold text-gray-900 dark:text-white">é“¾æ¥æ”¶è—å¤¹</h1>
          <div class="text-sm text-gray-500 dark:text-gray-400">
            <span id="linksCount">0</span> ä¸ªé“¾æ¥
          </div>
        </div>
        
        <div id="linkGroups" class="space-y-8">
          <!-- åŠ¨æ€ç”Ÿæˆ -->
        </div>
        <div id="noResults" class="hidden text-center py-16">
          <svg class="w-16 h-16 text-gray-300 dark:text-gray-700 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
          <p class="text-gray-500 dark:text-gray-400">æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„é“¾æ¥</p>
        </div>
      </main>
    </div>
    
    <!-- ç¼–è¾‘é¢æ¿ -->
    <div id="editorPanel" class="fixed inset-0 bg-black/50 z-40 hidden flex items-center justify-center p-4">
      <div class="bg-white dark:bg-dark-card rounded-xl shadow-xl w-full max-w-3xl max-h-[90vh] overflow-y-auto editor-panel">
        <div class="p-4 border-b border-gray-200 dark:border-dark-border flex justify-between items-center">
          <h2 class="text-xl font-bold text-gray-800 dark:text-white">ç¼–è¾‘é…ç½®</h2>
          <div class="flex gap-2">
            <button id="downloadConfigBtn" class="px-3 py-1.5 bg-blue-500 text-white rounded-lg text-sm hover:bg-blue-600 transition">
              ä¸‹è½½é…ç½®
            </button>
            <button id="closeEditorBtn" class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-dark-border">
              <svg class="w-5 h-5 text-gray-600 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="p-4">
          <textarea id="yamlEditor" class="w-full h-96 font-mono text-sm p-3 border border-gray-300 rounded-lg dark:bg-dark-card dark:border-dark-border dark:text-dark-text focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none" placeholder="åœ¨æ­¤ç¼–è¾‘YAMLé…ç½®..."></textarea>
          <div class="mt-4 flex justify-end gap-3">
            <button id="cancelEditBtn" class="px-4 py-2 text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-dark-border rounded-lg transition">å–æ¶ˆ</button>
            <button id="saveConfigBtn" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition">ä¿å­˜</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- æ•°æ®æºä¿¡æ¯ -->
    <div id="dataSourceInfo" class="fixed bottom-4 right-4 bg-white dark:bg-dark-card px-3 py-1.5 rounded-lg text-xs text-gray-600 dark:text-gray-400 shadow-md border border-gray-200 dark:border-dark-border transition-opacity duration-300 opacity-0">
      æ•°æ®æº: <span id="dataSourceUrl">-</span>
    </div>
    
    <!-- ä¿å­˜æˆåŠŸæç¤º -->
    <div id="saveSuccessToast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg opacity-0 transition-opacity duration-300 z-50">
      é…ç½®å·²ä¿å­˜ï¼
    </div>
  </div>

  <script>
    // ==================== é¢„å®šä¹‰é…è‰²æ–¹æ¡ˆ ====================
    const colorPalette = [
      '#3498db', '#2ecc71', '#e74c3c', '#9b59b6', '#f39c12', 
      '#1abc9c', '#34495e', '#16a085', '#27ae60', '#2980b9',
      '#8e44ad', '#2c3e50', '#f1c40f', '#e67e22', '#d35400'
    ];
    
    // ==================== çŠ¶æ€ç®¡ç† ====================
    let state = {
      activeGroupId: null,
      selectedTags: {}, // { groupId: [tagNames] }
      searchQuery: '',
      theme: 'system', // 'light', 'dark', 'system'
      editMode: false,
      data: {
        taggroups: [],
        links: []
      },
      dataSource: null,
      originalConfig: '',
      editedConfig: ''
    };
    
    // ==================== å·¥å…·å‡½æ•° ====================
    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    }
    
    function getColorForTag(tagName) {
      const index = hashString(tagName) % colorPalette.length;
      return colorPalette[index];
    }
    
    // ==================== Favicon è·å– ====================
    function getFaviconUrl(url) {
      try {
        const domain = new URL(url).hostname;
        
        // è¿”å›å¤šä¸ªfaviconæº
        return {
          primary: `https://www.google.com/s2/favicons?domain=${domain}&sz=64`,
          secondary: `https://favicon.is-an.org/?domain=${domain}&sz=64`,
          fallback: 'https://via.placeholder.com/64/3b82f6/ffffff?text=ğŸŒ'
        };
      } catch (e) {
        return {
          primary: 'https://via.placeholder.com/64/3b82f6/ffffff?text=ğŸŒ',
          secondary: 'https://via.placeholder.com/64/3b82f6/ffffff?text=ğŸŒ',
          fallback: 'https://via.placeholder.com/64/3b82f6/ffffff?text=ğŸŒ'
        };
      }
    }
    
    // ==================== æ•°æ®å¤„ç† ====================
    function processLoadedData(rawData) {
      // ç¡®ä¿æ•°æ®ç»“æ„æ­£ç¡®
      const processedData = {
        taggroups: [],
        links: []
      };
      
      // å¤„ç† taggroups
      if (rawData.taggroups && Array.isArray(rawData.taggroups)) {
        processedData.taggroups = rawData.taggroups.map(group => {
          // ä¸ºæ¯ä¸ªæ ‡ç­¾ç»„ä¸­çš„æ ‡ç­¾æ·»åŠ é¢œè‰²
          if (group.tags && Array.isArray(group.tags)) {
            group.tags = group.tags.map(tag => {
              if (typeof tag === 'string') {
                return {
                  name: tag,
                  color: getColorForTag(tag)
                };
              } else if (typeof tag === 'object' && tag.name) {
                return {
                  ...tag,
                  color: tag.color || getColorForTag(tag.name)
                };
              }
              return tag;
            });
          }
          return group;
        });
      } else {
        // å¦‚æœæ²¡æœ‰å®šä¹‰ taggroupsï¼Œå°è¯•ä»é“¾æ¥ä¸­è‡ªåŠ¨åˆ›å»º
        processedData.taggroups = autoGenerateTagGroups(rawData.links || []);
      }
      
      // å¤„ç† links
      if (rawData.links && Array.isArray(rawData.links)) {
        processedData.links = rawData.links.map(link => {
          // æ ‡å‡†åŒ–æ ‡ç­¾æ ¼å¼ï¼šç¡®ä¿ tags æ˜¯å­—ç¬¦ä¸²æ•°ç»„
          let tags = [];
          if (link.tags) {
            if (Array.isArray(link.tags)) {
              // ç›´æ¥ä½¿ç”¨æ•°ç»„ä¸­çš„å­—ç¬¦ä¸²
              tags = link.tags.filter(tag => typeof tag === 'string' || typeof tag === 'number').map(tag => String(tag));
            } else if (typeof link.tags === 'string') {
              // å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œåˆ†å‰²æˆæ•°ç»„
              tags = link.tags.split(',').map(tag => tag.trim());
            }
          }
          
          // åˆ›å»ºæ˜ å°„åçš„æ ‡ç­¾ç»“æ„
          const mappedTags = mapTagsToGroups(tags, processedData.taggroups);
          
          return {
            ...link,
            tags: mappedTags
          };
        });
      }
      
      return processedData;
    }
    
    function mapTagsToGroups(tags, taggroups) {
      // åˆ›å»ºç»“æœå¯¹è±¡ï¼Œæ ¼å¼ä¸º { groupId: [tagNames] }
      const result = {};
      
      // ä¸ºæ¯ä¸ªæ ‡ç­¾ç»„åˆå§‹åŒ–ç©ºæ•°ç»„
      taggroups.forEach(group => {
        result[group.id] = [];
      });
      
      // éå†æ‰€æœ‰æ ‡ç­¾ï¼Œå°†å®ƒä»¬åˆ†é…åˆ°å¯¹åº”çš„ç»„
      (tags || []).forEach(tagName => {
        let assigned = false;
        
        // å°è¯•æ‰¾åˆ°åŒ…å«æ­¤æ ‡ç­¾çš„ç»„
        for (const group of taggroups) {
          if (group.tags && Array.isArray(group.tags)) {
            // æ£€æŸ¥ç»„ä¸­æ˜¯å¦æœ‰æ­¤æ ‡ç­¾ï¼ˆå…¼å®¹å­—ç¬¦ä¸²å’Œå¯¹è±¡æ ¼å¼ï¼‰
            const tagExistsInGroup = group.tags.some(tagDef => 
              (typeof tagDef === 'string' && tagDef === tagName) || 
              (typeof tagDef === 'object' && tagDef.name === tagName)
            );
            
            if (tagExistsInGroup) {
              result[group.id].push(tagName);
              assigned = true;
              break;
            }
          }
        }
        
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ç»„ï¼Œæ”¾å…¥é»˜è®¤ç»„
        if (!assigned) {
          const defaultGroup = taggroups.find(g => g.default) || taggroups[0];
          if (defaultGroup) {
            result[defaultGroup.id].push(tagName);
          }
        }
      });
      
      return result;
    }
    
    function autoGenerateTagGroups(links) {
      // ä»æ‰€æœ‰é“¾æ¥ä¸­æå–å”¯ä¸€æ ‡ç­¾
      const allTags = new Set();
      links.forEach(link => {
        if (link.tags) {
          if (Array.isArray(link.tags)) {
            link.tags.forEach(tag => allTags.add(tag));
          } else if (typeof link.tags === 'string') {
            allTags.add(link.tags);
          }
        }
      });
      
      // åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„æ ‡ç­¾ç»„
      return [{
        id: 'default',
        name: 'æ ‡ç­¾',
        default: true,
        tags: Array.from(allTags).map(tagName => ({
          name: tagName,
          color: getColorForTag(tagName)
        }))
      }];
    }
    
    function getTagDefinition(tagName, taggroups) {
      for (const group of taggroups) {
        if (group.tags) {
          const tagDef = group.tags.find(t => t.name === tagName);
          if (tagDef) {
            return {
              ...tagDef,
              groupId: group.id,
              groupName: group.name
            };
          }
        }
      }
      return null;
    }
    
    // ==================== æ•°æ®åŠ è½½ ====================
    async function loadDataFromUrl(url) {
      try {
        // å¤„ç†ç›¸å¯¹è·¯å¾„
        const absoluteUrl = new URL(url, window.location.href).href;
        
        const response = await fetch(absoluteUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        
        const contentType = response.headers.get('content-type');
        let data;
        
        if (contentType && contentType.includes('application/json')) {
          data = await response.json();
        } else {
          // å‡è®¾æ˜¯YAML
          const yamlText = await response.text();
          data = jsyaml.load(yamlText);
          
          // ä¿å­˜åŸå§‹YAMLå†…å®¹ç”¨äºç¼–è¾‘
          state.originalConfig = yamlText;
          state.editedConfig = yamlText;
        }
        
        return data;
      } catch (error) {
        console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
        throw error;
      }
    }
    
    async function initApp() {
      showLoading(true);
      
      try {
        // 1. è·å–æ•°æ®æºURL
        const params = new URLSearchParams(window.location.search);
        let dataSourceUrl = params.get('data');
        
        // 2. å¦‚æœæ²¡æœ‰æŒ‡å®šæ•°æ®æºï¼Œå°è¯•ä»localStorageè·å–æœ€åä½¿ç”¨çš„
        if (!dataSourceUrl) {
          dataSourceUrl = localStorage.getItem('lastDataSource');
        }
        
        // 3. å¦‚æœä»ç„¶æ²¡æœ‰ï¼Œä½¿ç”¨é»˜è®¤ ./default.yaml
        if (!dataSourceUrl) {
          dataSourceUrl = './default.yaml';
        }
        
        // 4. åŠ è½½æ•°æ®
        state.dataSource = dataSourceUrl;
        
        try {
          // å°è¯•åŠ è½½æŒ‡å®šçš„æ•°æ®æº
          const rawData = await loadDataFromUrl(dataSourceUrl);
          state.data = processLoadedData(rawData);
        } catch (error) {
          console.error('åŠ è½½æŒ‡å®šæ•°æ®æºå¤±è´¥:', error);
          
          if (dataSourceUrl === './default.yaml') {
            // å¦‚æœæ˜¯é»˜è®¤æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®ç¤ºä¾‹æ•°æ®
            console.log('ä½¿ç”¨å†…ç½®ç¤ºä¾‹æ•°æ®');
            state.data = processLoadedData(getExampleData());
            state.dataSource = 'å†…ç½®ç¤ºä¾‹';
          } else {
            // å°è¯•åŠ è½½é»˜è®¤æ–‡ä»¶
            try {
              console.log('å°è¯•åŠ è½½é»˜è®¤é…ç½®æ–‡ä»¶ ./default.yaml');
              const rawData = await loadDataFromUrl('./default.yaml');
              state.data = processLoadedData(rawData);
              state.dataSource = './default.yaml';
            } catch (fallbackError) {
              console.error('åŠ è½½é»˜è®¤é…ç½®æ–‡ä»¶ä¹Ÿå¤±è´¥:', fallbackError);
              state.data = processLoadedData(getExampleData());
              state.dataSource = 'å†…ç½®ç¤ºä¾‹';
            }
          }
        }
        
        // 5. ä¿å­˜æ•°æ®æº
        localStorage.setItem('lastDataSource', state.dataSource);
        
        // 6. æ›´æ–°UIæ˜¾ç¤ºæ•°æ®æº
        document.getElementById('dataSourceUrl').textContent = state.dataSource;
        document.getElementById('dataSourceInfo').classList.add('opacity-100');
        
        // 7. è®¾ç½®æ´»åŠ¨æ ‡ç­¾ç»„ - ä¼˜å…ˆä½¿ç”¨é»˜è®¤ç»„
        const defaultGroup = state.data.taggroups.find(g => g.default);
        state.activeGroupId = defaultGroup ? defaultGroup.id : (state.data.taggroups[0]?.id || 'default');
        
        // 8. åŠ è½½ç”¨æˆ·çŠ¶æ€
        loadState();
        
        // 9. æ¸²æŸ“åº”ç”¨
        render();
      } catch (error) {
        console.error('åˆå§‹åŒ–åº”ç”¨å¤±è´¥:', error);
        alert('åˆå§‹åŒ–åº”ç”¨å¤±è´¥: ' + error.message);
      } finally {
        showLoading(false);
      }
    }
    
    function getExampleData() {
      return {
        taggroups: [
          {
            id: 'language',
            name: 'è¯­è¨€',
            default: true,
            tags: ['ä¸­æ–‡', 'English']
          },
          {
            id: 'category',
            name: 'åˆ†ç±»',
            default: false,
            tags: ['æŠ€æœ¯', 'ç¤¾åŒº', 'å¼€æº']
          },
          {
            id: 'features',
            name: 'ç‰¹ç‚¹',
            default: false,
            tags: ['é«˜è´¨é‡å†…å®¹', 'ä»˜è´¹å¢™']
          }
        ],
        links: [
          {
            title: 'GitHub',
            url: 'https://github.com',
            description: 'å…¨çƒæœ€å¤§çš„ä»£ç æ‰˜ç®¡å¹³å°',
            tags: ['English', 'æŠ€æœ¯', 'å¼€æº']
          },
          {
            title: 'æ˜é‡‘',
            url: 'https://juejin.cn',
            description: 'ä¸­æ–‡æŠ€æœ¯ç¤¾åŒº',
            tags: ['ä¸­æ–‡', 'æŠ€æœ¯', 'ç¤¾åŒº']
          },
          {
            title: 'çŸ¥ä¹',
            url: 'https://www.zhihu.com',
            description: 'ä¸­æ–‡é—®ç­”ç¤¾åŒº',
            tags: ['ä¸­æ–‡', 'ç¤¾åŒº', 'é«˜è´¨é‡å†…å®¹']
          },
          {
            title: 'çº½çº¦æ—¶æŠ¥',
            url: 'https://www.nytimes.com',
            description: 'å›½é™…æ–°é—»åª’ä½“',
            tags: ['English', 'é«˜è´¨é‡å†…å®¹', 'ä»˜è´¹å¢™']
          },
          {
            title: 'MDN Web Docs',
            url: 'https://developer.mozilla.org',
            description: 'WebæŠ€æœ¯æ–‡æ¡£',
            tags: ['English', 'ä¸­æ–‡', 'æŠ€æœ¯', 'é«˜è´¨é‡å†…å®¹']
          },
          {
            title: 'Stack Overflow',
            url: 'https://stackoverflow.com',
            description: 'ç¨‹åºå‘˜é—®ç­”ç¤¾åŒº',
            tags: ['English', 'æŠ€æœ¯', 'é«˜è´¨é‡å†…å®¹']
          }
        ]
      };
    }
    
    function showLoading(show) {
      document.getElementById('loadingOverlay').style.opacity = show ? '1' : '0';
      document.getElementById('loadingOverlay').style.pointerEvents = show ? 'all' : 'none';
    }
    
    // ==================== çŠ¶æ€ç®¡ç† ====================
    function loadState() {
      const savedState = localStorage.getItem('linkManagerState');
      const defaultState = {
        selectedTags: {},
        searchQuery: '',
        theme: 'system',
        editMode: false
      };
      
      if (savedState) {
        try {
          const parsed = JSON.parse(savedState);
          // åªæ¢å¤ç›¸å…³çŠ¶æ€ï¼Œä¸æ¢å¤activeGroupId
          state.selectedTags = parsed.selectedTags || {};
          state.theme = parsed.theme || 'system';
          state.editMode = parsed.editMode || false;
        } catch (e) {
          console.error('è§£æä¿å­˜çš„çŠ¶æ€å¤±è´¥:', e);
          Object.assign(state, defaultState);
        }
      } else {
        Object.assign(state, defaultState);
      }
      
      // ä»URLå‚æ•°æ¢å¤æœç´¢
      const params = new URLSearchParams(window.location.search);
      const urlSearch = params.get('q');
      if (urlSearch) {
        state.searchQuery = urlSearch;
        document.getElementById('searchInput').value = urlSearch;
      }
      
      // åº”ç”¨ç¼–è¾‘æ¨¡å¼
      document.body.classList.toggle('edit-mode', state.editMode);
      
      applyTheme();
    }
    
    function saveState() {
      localStorage.setItem('linkManagerState', JSON.stringify({
        selectedTags: state.selectedTags,
        theme: state.theme,
        editMode: state.editMode
      }));
      
      // æ›´æ–°URL
      const params = new URLSearchParams(window.location.search);
      if (state.searchQuery) {
        params.set('q', state.searchQuery);
      } else {
        params.delete('q');
      }
      
      if (state.dataSource && state.dataSource !== './default.yaml') {
        params.set('data', state.dataSource);
      } else {
        params.delete('data');
      }
      
      params.set('group', state.activeGroupId);
      
      if (Object.keys(state.selectedTags).length > 0) {
        params.set('tags', encodeURIComponent(JSON.stringify(state.selectedTags)));
      } else {
        params.delete('tags');
      }
      
      const newUrl = `${window.location.pathname}?${params.toString()}`;
      window.history.replaceState({}, '', newUrl);
    }
    
    // ==================== æš—è‰²æ¨¡å¼åŠŸèƒ½ ====================
    function getSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    
    function applyTheme() {
      const htmlElement = document.documentElement;
      
      if (state.theme === 'system') {
        const systemTheme = getSystemTheme();
        htmlElement.classList.toggle('dark', systemTheme === 'dark');
      } else {
        htmlElement.classList.toggle('dark', state.theme === 'dark');
      }
      
      // æ›´æ–°ä¸»é¢˜åˆ‡æ¢æŒ‰é’®çŠ¶æ€
      const themeToggle = document.getElementById('themeToggle');
      if (themeToggle) {
        themeToggle.querySelector('svg').innerHTML = state.theme === 'dark' ? 
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/>' :
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/>';
        
        themeToggle.classList.toggle('dark', state.theme === 'dark');
      }
      
      // æ›´æ–°ç¼–è¾‘æ¨¡å¼ä¸‹çš„ä¸»é¢˜
      const editorPanel = document.getElementById('editorPanel');
      if (editorPanel) {
        editorPanel.classList.toggle('dark', htmlElement.classList.contains('dark'));
      }
    }
    
    function toggleTheme() {
      if (state.theme === 'system') {
        state.theme = getSystemTheme() === 'dark' ? 'light' : 'dark';
      } else if (state.theme === 'dark') {
        state.theme = 'light';
      } else {
        state.theme = 'system';
      }
      
      applyTheme();
      saveState();
    }
    
    function toggleEditMode() {
      state.editMode = !state.editMode;
      document.body.classList.toggle('edit-mode', state.editMode);
      saveState();
      
      if (state.editMode) {
        // è¿›å…¥ç¼–è¾‘æ¨¡å¼ï¼Œæ˜¾ç¤ºç¼–è¾‘é¢æ¿
        showEditorPanel();
      }
    }
    
    function showEditorPanel() {
      const editorPanel = document.getElementById('editorPanel');
      const yamlEditor = document.getElementById('yamlEditor');
      
      // è®¾ç½®ç¼–è¾‘å™¨å†…å®¹
      yamlEditor.value = state.editedConfig || state.originalConfig || jsyaml.dump({
        taggroups: state.data.taggroups.map(group => ({
          id: group.id,
          name: group.name,
          default: group.default,
          tags: group.tags.map(tag => tag.name)
        })),
        links: state.data.links.map(link => ({
          title: link.title,
          url: link.url,
          description: link.description,
          tags: Object.values(link.tags).flat()
        }))
      });
      
      editorPanel.classList.remove('hidden');
    }
    
    function closeEditorPanel() {
      document.getElementById('editorPanel').classList.add('hidden');
    }
    
    // ==================== æœç´¢è§£æ ====================
    function parseSearchQuery(query) {
      const result = {
        text: [],
        includeTags: [], // { groupId, tagName } æˆ– tagåç§°
        excludeTags: []  // tagåç§°
      };
    
      if (!query.trim()) return result;
    
      const tokens = query.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
      
      for (const token of tokens) {
        if (token.startsWith('-tag:')) {
          // æ’é™¤æ ‡ç­¾
          const tagName = token.slice(5);
          result.excludeTags.push(tagName);
        } else if (token.startsWith('tag:')) {
          // åŒ…å«æ ‡ç­¾
          const tagName = token.slice(4);
          result.includeTags.push(tagName);
        } else {
          // æ™®é€šæ–‡æœ¬æœç´¢
          result.text.push(token.replace(/"/g, '').toLowerCase());
        }
      }
    
      return result;
    }
    
    // ==================== ç­›é€‰é€»è¾‘ ====================
    function filterLinks() {
      const searchParsed = parseSearchQuery(state.searchQuery);
      const { links, taggroups } = state.data;
      const activeGroup = taggroups.find(g => g.id === state.activeGroupId);
      const selectedTagsForGroup = state.selectedTags[state.activeGroupId] || [];
    
      return links.filter(link => {
        // 1. æ£€æŸ¥å½“å‰åˆ†ç»„çš„æ ‡ç­¾ç­›é€‰
        if (selectedTagsForGroup.length > 0) {
          const linkTags = link.tags[state.activeGroupId] || [];
          // é“¾æ¥å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªé€‰ä¸­çš„æ ‡ç­¾
          if (!selectedTagsForGroup.some(t => linkTags.includes(t))) {
            return false;
          }
        }
    
        // 2. æ£€æŸ¥æœç´¢è¯­æ³•ä¸­çš„æ ‡ç­¾åŒ…å«
        for (const includeTag of searchParsed.includeTags) {
          let hasTag = false;
          
          // æ£€æŸ¥é“¾æ¥æ˜¯å¦åŒ…å«è¯¥æ ‡ç­¾
          for (const [groupId, tagNames] of Object.entries(link.tags)) {
            if (tagNames.includes(includeTag)) {
              hasTag = true;
              break;
            }
          }
          
          if (!hasTag) {
            return false;
          }
        }
    
        // 3. æ£€æŸ¥æœç´¢è¯­æ³•ä¸­çš„æ ‡ç­¾æ’é™¤
        for (const excludeTag of searchParsed.excludeTags) {
          // åœ¨æ‰€æœ‰åˆ†ç»„ä¸­æŸ¥æ‰¾è¯¥æ ‡ç­¾
          for (const tagNames of Object.values(link.tags)) {
            if (tagNames.includes(excludeTag)) {
              return false;
            }
          }
        }
    
        // 4. æ–‡æœ¬æœç´¢
        if (searchParsed.text.length > 0) {
          const searchableText = `${link.title} ${link.description || ''} ${link.url}`.toLowerCase();
          if (!searchParsed.text.every(t => searchableText.includes(t.toLowerCase()))) {
            return false;
          }
        }
    
        return true;
      });
    }
    
    // æŒ‰å½“å‰åˆ†ç»„çš„æ ‡ç­¾ç»„ç»‡é“¾æ¥
    function groupLinksByTag(filteredLinks) {
      const activeGroup = state.data.taggroups.find(g => g.id === state.activeGroupId);
      const groups = {};
      const noTagLinks = [];
      
      // åˆå§‹åŒ–æ‰€æœ‰æ ‡ç­¾ç»„
      if (activeGroup && activeGroup.tags) {
        activeGroup.tags.forEach(tag => {
          groups[tag.name] = [];
        });
      }
    
      // åˆ†é…é“¾æ¥
      filteredLinks.forEach(link => {
        const linkTags = link.tags[state.activeGroupId] || [];
        if (linkTags.length === 0) {
          noTagLinks.push(link);
        } else {
          linkTags.forEach(tagName => {
            if (groups[tagName]) {
              groups[tagName].push(link);
            }
          });
        }
      });
    
      return { groups, noTagLinks };
    }
    
    // ==================== æ¸²æŸ“å‡½æ•° ====================
    function renderTagGroupSelector() {
      const container = document.getElementById('tagGroupSelector');
      const { taggroups } = state.data;
      
      container.innerHTML = taggroups.map(group => `
        <button 
          onclick="switchTagGroup('${group.id}')"
          class="px-3 py-1.5 rounded-full text-sm font-medium transition-all whitespace-nowrap
            ${state.activeGroupId === group.id 
              ? 'bg-blue-500 text-white shadow-md' 
              : 'bg-gray-100 text-gray-600 hover:bg-gray-200 dark:bg-dark-border dark:text-gray-300 dark:hover:bg-gray-700'}"
        >
          ${group.name}
        </button>
      `).join('');
    }
    
    function renderTagList() {
      const container = document.getElementById('tagList');
      const titleEl = document.getElementById('sidebarTitle');
      const { taggroups } = state.data;
      const activeGroup = taggroups.find(g => g.id === state.activeGroupId);
      const selectedTags = state.selectedTags[state.activeGroupId] || [];
      
      if (activeGroup) {
        titleEl.textContent = activeGroup.name;
      }
    
      // è®¡ç®—æ¯ä¸ªæ ‡ç­¾çš„é“¾æ¥æ•°é‡
      const tagCounts = {};
      if (activeGroup && activeGroup.tags) {
        activeGroup.tags.forEach(tag => {
          tagCounts[tag.name] = state.data.links.filter(link => 
            (link.tags[state.activeGroupId] || []).includes(tag.name)
          ).length;
        });
      }
    
      if (!activeGroup || !activeGroup.tags || activeGroup.tags.length === 0) {
        container.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-sm">è¯¥åˆ†ç»„æ²¡æœ‰æ ‡ç­¾</p>';
        return;
      }
      
      container.innerHTML = `
        <button 
          onclick="clearTagSelection()"
          class="w-full text-left px-3 py-2 rounded-lg text-sm transition-all
            ${selectedTags.length === 0 
              ? 'bg-gray-100 font-medium dark:bg-gray-700 dark:text-white' 
              : 'hover:bg-gray-50 dark:hover:bg-gray-800 text-gray-600 dark:text-gray-400'}"
        >
          å…¨éƒ¨ <span class="text-gray-400 dark:text-gray-500">(${state.data.links.length})</span>
        </button>
        ${activeGroup.tags.map(tag => {
          const isSelected = selectedTags.includes(tag.name);
          const foregroundColor = getForegroundColor(tag.color);
          
          return `
            <button 
              onclick="toggleTag('${tag.name}')"
              class="w-full text-left px-3 py-2 rounded-lg text-sm transition-all flex items-center gap-2
                ${isSelected 
                  ? 'bg-gray-100 font-medium ring-2 ring-offset-1 dark:bg-gray-700 dark:text-white' 
                  : 'hover:bg-gray-50 dark:hover:bg-gray-800 text-gray-600 dark:text-gray-300'}"
              style="color: ${isSelected ? '' : foregroundColor}; ${isSelected ? `--tw-ring-color: ${tag.color}` : ''}"
            >
              <span class="w-3 h-3 rounded-full flex-shrink-0" style="background-color: ${tag.color}"></span>
              <span class="flex-1">${tag.name}</span>
              <span class="text-gray-400 dark:text-gray-500">(${tagCounts[tag.name] || 0})</span>
            </button>
          `;
        }).join('')}
      `;
    }
    
    function getForegroundColor(hexColor) {
      // è®¡ç®—äº®åº¦
      const r = parseInt(hexColor.slice(1, 3), 16);
      const g = parseInt(hexColor.slice(3, 5), 16);
      const b = parseInt(hexColor.slice(5, 7), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      
      // å¦‚æœäº®åº¦é«˜ï¼Œä½¿ç”¨æ·±è‰²æ–‡å­—ï¼›å¦‚æœäº®åº¦ä½ï¼Œä½¿ç”¨æµ…è‰²æ–‡å­—
      return brightness > 128 ? '#333333' : '#ffffff';
    }
    
    function renderLinks() {
      const container = document.getElementById('linkGroups');
      const noResults = document.getElementById('noResults');
      const filteredLinks = filterLinks();
      const { groups, noTagLinks } = groupLinksByTag(filteredLinks);
      const activeGroup = state.data.taggroups.find(g => g.id === state.activeGroupId);
      
      // æ›´æ–°é“¾æ¥è®¡æ•°
      document.getElementById('linksCount').textContent = filteredLinks.length;
      
      if (filteredLinks.length === 0) {
        container.innerHTML = '';
        noResults.classList.remove('hidden');
        return;
      }
    
      noResults.classList.add('hidden');
    
      let html = '';
      
      // æ¸²æŸ“æ¯ä¸ªæ ‡ç­¾ç»„
      if (activeGroup && activeGroup.tags) {
        activeGroup.tags.forEach(tag => {
          const tagLinks = groups[tag.name] || [];
          if (tagLinks.length === 0) return;
          
          html += `
            <section>
              <div class="flex items-center gap-2 mb-4">
                <span class="w-4 h-4 rounded-full" style="background-color: ${tag.color}"></span>
                <h2 class="text-lg font-semibold text-gray-800 dark:text-white">${tag.name}</h2>
                <span class="text-sm text-gray-400 dark:text-gray-500">(${tagLinks.length})</span>
              </div>
              <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
                ${tagLinks.map(link => renderLinkCard(link)).join('')}
              </div>
            </section>
          `;
        });
      }
    
      // æ¸²æŸ“æ— æ ‡ç­¾çš„é“¾æ¥
      if (noTagLinks.length > 0) {
        html += `
          <section>
            <div class="flex items-center gap-2 mb-4">
              <span class="w-4 h-4 rounded-full bg-gray-300 dark:bg-gray-600"></span>
              <h2 class="text-lg font-semibold text-gray-800 dark:text-white">æœªåˆ†ç±»</h2>
              <span class="text-sm text-gray-400 dark:text-gray-500">(${noTagLinks.length})</span>
            </div>
            <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
              ${noTagLinks.map(link => renderLinkCard(link)).join('')}
            </div>
          </section>
        `;
      }
    
      container.innerHTML = html;
    }
    
    function renderLinkCard(link) {
      // è·å–é“¾æ¥çš„æ‰€æœ‰æ ‡ç­¾
      const allTags = [];
      for (const [groupId, tagNames] of Object.entries(link.tags)) {
        const group = state.data.taggroups.find(g => g.id === groupId);
        if (group) {
          tagNames.forEach(tagName => {
            const tagDef = group.tags.find(t => t.name === tagName);
            if (tagDef) {
              allTags.push({
                ...tagDef,
                groupId,
                groupName: group.name
              });
            }
          });
        }
      }
      
      // è·å–ç½‘ç«™å›¾æ ‡
      const favicon = getFaviconUrl(link.url);
      
      return `
        <a href="${link.url}" target="_blank" rel="noopener noreferrer nofollow"
           class="link-card block bg-white dark:bg-dark-card rounded-xl p-4 border border-gray-200 dark:border-dark-border hover:border-blue-300 dark:hover:border-blue-500">
          <div class="flex items-start gap-3">
            <div class="flex-shrink-0 w-10 h-10 rounded-full overflow-hidden flex items-center justify-center bg-gray-100 dark:bg-gray-800 border border-gray-200 dark:border-dark-border">
              <img src="${favicon.primary}" alt="" class="w-6 h-6 object-contain favicon-loader" 
                   onerror="this.onerror=null; this.src='${favicon.secondary}'" 
                   onload="this.classList.remove('favicon-loader')">
            </div>
            <div class="flex-1 min-w-0">
              <h3 class="font-semibold text-gray-900 dark:text-white mb-1 flex items-center gap-2">
                <span class="truncate">${link.title}</span>
                <svg class="w-4 h-4 text-gray-400 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
                </svg>
              </h3>
              <p class="text-sm text-gray-500 dark:text-gray-400 mb-3 line-clamp-2">${link.description || 'æš‚æ— æè¿°'}</p>
              <div class="flex flex-wrap gap-1.5">
                ${allTags.map(tag => `
                  <span 
                    class="tag-pill px-2 py-0.5 rounded-full text-xs font-medium"
                    style="background-color: ${tag.color}; color: ${getForegroundColor(tag.color)};"
                    title="${tag.groupName}"
                  >${tag.name}</span>
                `).join('')}
              </div>
            </div>
          </div>
        </a>
      `;
    }
    
    function render() {
      renderTagGroupSelector();
      renderTagList();
      renderLinks();
    }
    
    // ==================== äº‹ä»¶å¤„ç† ====================
    function switchTagGroup(groupId) {
      state.activeGroupId = groupId;
      saveState();
      render();
    }
    
    function toggleTag(tagName) {
      const activeGroup = state.data.taggroups.find(g => g.id === state.activeGroupId);
      let selectedTags = state.selectedTags[state.activeGroupId] || [];
      
      // åˆ‡æ¢æ ‡ç­¾é€‰æ‹©
      if (selectedTags.includes(tagName)) {
        selectedTags = selectedTags.filter(t => t !== tagName);
      } else {
        selectedTags = [...selectedTags, tagName];
      }
      
      if (selectedTags.length === 0) {
        delete state.selectedTags[state.activeGroupId];
      } else {
        state.selectedTags[state.activeGroupId] = selectedTags;
      }
      
      saveState();
      render();
    }
    
    function clearTagSelection() {
      delete state.selectedTags[state.activeGroupId];
      saveState();
      render();
    }
    
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      const overlay = document.getElementById('overlay');
      sidebar.classList.toggle('hidden-mobile');
      overlay.classList.toggle('hidden');
    }
    
    function showSaveSuccess() {
      const toast = document.getElementById('saveSuccessToast');
      toast.style.opacity = '1';
      
      setTimeout(() => {
        toast.style.opacity = '0';
      }, 2000);
    }
    
    function saveConfig() {
      const yamlEditor = document.getElementById('yamlEditor');
      const yamlContent = yamlEditor.value;
      
      try {
        // éªŒè¯YAMLæ ¼å¼
        const parsedData = jsyaml.load(yamlContent);
        
        // ä¿å­˜åˆ°localStorage
        localStorage.setItem('customConfig', yamlContent);
        
        // æ›´æ–°åº”ç”¨æ•°æ®
        state.data = processLoadedData(parsedData);
        state.originalConfig = yamlContent;
        state.editedConfig = yamlContent;
        
        // è®¾ç½®æ•°æ®æºä¸º"è‡ªå®šä¹‰é…ç½®"
        state.dataSource = 'è‡ªå®šä¹‰é…ç½®';
        document.getElementById('dataSourceUrl').textContent = state.dataSource;
        
        // é‡æ–°æ¸²æŸ“
        render();
        
        // å…³é—­ç¼–è¾‘é¢æ¿
        closeEditorPanel();
        
        // æ˜¾ç¤ºæˆåŠŸæç¤º
        showSaveSuccess();
      } catch (error) {
        alert('ä¿å­˜é…ç½®å¤±è´¥: ' + error.message + '\n\nè¯·æ£€æŸ¥YAMLæ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚');
        console.error('YAMLè§£æé”™è¯¯:', error);
      }
    }
    
    function downloadConfig() {
      const yamlContent = document.getElementById('yamlEditor').value;
      
      // åˆ›å»ºä¸‹è½½é“¾æ¥
      const blob = new Blob([yamlContent], { type: 'application/yaml' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'links-collection.yaml';
      document.body.appendChild(a);
      a.click();
      
      // æ¸…ç†
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }
    
    // ==================== åˆå§‹åŒ– ====================
    document.addEventListener('DOMContentLoaded', () => {
      // åˆå§‹åŒ–ä¸»é¢˜åˆ‡æ¢æŒ‰é’®
      document.getElementById('themeToggle').addEventListener('click', toggleTheme);
      
      // æœç´¢è¾“å…¥ç›‘å¬
      const searchInput = document.getElementById('searchInput');
      let debounceTimer;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          state.searchQuery = e.target.value;
          saveState();
          renderLinks();
        }, 300);
      });
      
      // ç§»åŠ¨ç«¯èœå•åˆ‡æ¢
      document.getElementById('menuToggle').addEventListener('click', toggleSidebar);
      
      // ç¼–è¾‘æ¨¡å¼åˆ‡æ¢
      document.getElementById('editModeToggle').addEventListener('click', toggleEditMode);
      
      // ç¼–è¾‘é¢æ¿äº‹ä»¶
      document.getElementById('closeEditorBtn').addEventListener('click', closeEditorPanel);
      document.getElementById('cancelEditBtn').addEventListener('click', closeEditorPanel);
      document.getElementById('saveConfigBtn').addEventListener('click', saveConfig);
      document.getElementById('downloadConfigBtn').addEventListener('click', downloadConfig);
      
      // ç‚¹å‡»é®ç½©å…³é—­ç¼–è¾‘é¢æ¿
      document.getElementById('editorPanel').addEventListener('click', (e) => {
        if (e.target === document.getElementById('editorPanel')) {
          closeEditorPanel();
        }
      });
      
      // å¤„ç†æµè§ˆå™¨å‰è¿›åé€€
      window.addEventListener('popstate', () => {
        loadState();
        document.getElementById('searchInput').value = state.searchQuery;
        
        // ä»URLæ¢å¤ activeGroupId
        const params = new URLSearchParams(window.location.search);
        const urlGroup = params.get('group');
        if (urlGroup) {
          state.activeGroupId = urlGroup;
        }
        
        // ä»URLæ¢å¤ selectedTags
        const urlTags = params.get('tags');
        if (urlTags) {
          try {
            state.selectedTags = JSON.parse(decodeURIComponent(urlTags));
          } catch (e) {
            console.error('è§£æURLæ ‡ç­¾å¤±è´¥:', e);
            state.selectedTags = {};
          }
        }
        
        render();
      });
      
      // ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        if (state.theme === 'system') {
          applyTheme();
        }
      });
      
      // åˆå§‹åŒ–åº”ç”¨
      initApp();
      
      // æ£€æŸ¥æ˜¯å¦å­˜åœ¨è‡ªå®šä¹‰é…ç½®
      const customConfig = localStorage.getItem('customConfig');
      if (customConfig) {
        // å¦‚æœæœ‰è‡ªå®šä¹‰é…ç½®ï¼Œä½¿ç”¨å®ƒ
        try {
          const parsedData = jsyaml.load(customConfig);
          state.data = processLoadedData(parsedData);
          state.dataSource = 'è‡ªå®šä¹‰é…ç½®';
          document.getElementById('dataSourceUrl').textContent = state.dataSource;
          document.getElementById('dataSourceInfo').classList.add('opacity-100');
        } catch (e) {
          console.error('åŠ è½½è‡ªå®šä¹‰é…ç½®å¤±è´¥:', e);
        }
      }
    });
    
    // å…¨å±€å‡½æ•°ï¼ˆç”¨äºHTMLä¸­çš„onclickï¼‰
    window.switchTagGroup = switchTagGroup;
    window.toggleTag = toggleTag;
    window.clearTagSelection = clearTagSelection;
    window.toggleSidebar = toggleSidebar;
  </script>
</body>
</html>